# 코드 명세

1. 도메인 지식을 정확히, 자세히 알아야 한다. 더 자세한 테스트 작성을 하기 위해서

# 테스트 기법

## 수동 테스트(QA).

- UI를 이용해 테스트
- 최종 사용자와 가장 비슷하게 검증.
- 가장 온전한 코드 실행.
- 인수 테스트. 개발한대로 작동이 되는지 테스트

### 단점

- 실행 비용이 높고 결과의 변동이 크다.

### 소프트웨어 회귀

- 원래 동작하던 것들이 주변 환경(사건, 시점, 코드 배포, 시스템 업데이트..)에 의해서 동작하지 않는다.
- 새로운 기능이 추가되면 기존의 기능이 작동하지 않음.
- 소프트웨어의 기능은 시간이 지날수록 늘어난다. -> 더더욱 시간이 늘어남

### 테스트 자동화

1. 사람이 아니라 기계(코드)가 기능을 검증한다.
2. 코드 작성엔 비용이 들지만 한 번 작성된 코드를 실행하는데는 비용이 낮고 신뢰도가 높다.
3. 테스트 코드 작성과 관리는 프로그래머 역량에 크게 영향을 받는다.

### 인수테스트

1. 배치된 시스템을 대상으로 검증
2. 전체 시스템 이상 여부를 판단해 신뢰도가 높다
3. 작성, 관리, 실행 비용이 높다
4. 피드백 품질이 낮다. -> 문제는 있어 근데 왜, 어디서, 어떻게 일어났는지에 대한 피드백은 받을 수 없다.

### 단위테스트

1. 일부만 떼어서 테스트한다.( 하위 시스템을 대상 )
2. 작성, 관리, 실행 비용이 낮다.
3. 높은 피드백 ( 왜, 어디서 문제가 났는지 알 수 있음 )
4. 전체 시스템 테스트 신뢰도는 낮음.

# 코드 분해

- 프로그래머는 한 번에 다룰 수 문제의 크기는 한계가 있음 -> 작은 문제로 분해, 그 일부는 반복된다.

## 코드 재사용

1. 작은 문제는 재사용이 가능하다. ( 반복되는 문제 재사용 ). 건들지 않고 재사용하는게 중요. 사이드 이펙트를 방지하기 위해
2. 코드 재사용은 소프트웨어 비용 절감 효과가 있다.

## 모듈화 ( 재사용할 수 있는 인터페이스, 구현 같은..)

1. 분해
2. 조립
3. 단위 테스트

### 모듈 (인터페이스 + 구현)

- 인터페이스: 모듈이 어떤 기능을 제공하는 지. 기능을 제공받기 위해선 어떻게 사용하는지
- 구현: 그래서 그 기능이 어떻게 만들어지는 지 표현
- 인터페이스를 고려해서 시스템을 설계한다.
- 잘 설계되어 있다면 코드를 읽는 시간을 감소시킨다.
- 충분히 신뢰할 수 있어야 마음놓고 사용할 수 있다. 잘 테스트해서 제공해줘야 한다.
- 수동보단 자동화 코드를 사용하고 단위테스트를 사용한다.

# 단위테스트

## 문자열을 입력해 가공하는 함수 테스트

- 중복된 문자열을 제거해주는 함수.
- sut: system under test
- 테스트 코드의 양이 준다고 좋은게 아니다. 예를들어 for of를 이용해 한번에 작성한다면 코드는 줄지면 그만큼 피드백 퀄리티가 낮아진다.
- 이를 해결하기 위해 jest의 test.each(table)을 이용할 수 있다. -> 각각 모두 돌아줌

# 테스트 우선 개발 (test first development)

## 테스트코드란

- 가시적이고 구체적인 목표를 세울 수 있음
- 자가 검증 가능
- 반복 실행
- 운영코드의 api의 클라이언트가 된다.

## 운영코드보다 테스트 코드를 먼저 작성한다.

1. 명확하고 검증 가능한 목표를 설정한 후 목표를 설립할 수 있다.
   프로그래머는 기능 명세, 요구 사항을 더 확실히 파악하고 시작할 수 있다.
